#!/bin/bash

NC="\033[0m"
BOLD="\033[1m"
ULINE="\033[4m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
MAGENTA="\033[35m"

fatal_error()
{
	if [ -z "$1" ]
	then
		message="fatal error"
	else
		message="$1"
	fi
	if [ -z "$2" ]
	then
		exit_status=1
	else
		exit_status=$2
	fi
	printf "${RED}$message${NC}\n"
	exit $exit_status
}

DISABLE_TIMEOUT=0

wait_for_timeout()
{
	sleep 5
	kill $bg_process
}

pipex_test()
{
	if [ $DISABLE_TIMEOUT -eq 0 ]
	then
		"$@" &
		bg_process=$!
		wait_for_timeout $bg_process &
		wait $bg_process
	else
		"$@"
	fi
	status_code=$?
	return $status_code
}

TESTS_OK=0
TESTS_KO=0
TESTS_TO=0
exec 3>&1

pipex_summary()
{
	exec 1>&3
	printf "\n\n"
	printf "\t${BOLD}Summary${NC}\n\n" > /dev/stdout
	
	printf "${GREEN}$TESTS_OK OK${NC} - ${RED}$TESTS_KO KO${NC} - ${RED}$TESTS_TO TO${NC}\n\n"
	
	printf "${GREEN}OK${NC}: Test passed\n"
	printf "${YELLOW}OK${NC}: Not opitmal or like bash (should not invalidate the project)\n"
	printf "${RED}KO${NC}: Test did not pass\n"
	printf "${RED}TO${NC}: Test timed out\n"
	
	if [ $TESTS_KO -eq 0 ] && [ $TESTS_TO -eq 0 ]
	then
		exit 0
	else
		exit 1
	fi
}

cd "$(dirname "$0")"

printf "+------------------------------------------------------------------------------+\n"
printf "|                                                                              |\n"
printf "|                                                                              |\n"
printf "|                           ${ULINE}${MAGENTA}PIPEX TESTER${NC} by ${YELLOW}vfurmane${NC}                           |\n"
printf "|                                                                              |\n"
printf "|                                                                              |\n"
printf "+------------------------------------------------------------------------------+\n"
printf "\n\n"

ONLY_CONFIG=0
READ_CONFIG=1

trap pipex_summary SIGINT

# Parse arguments
while [ $# -gt 0 ]
do
	case $1 in
		-c|--config)
			ONLY_CONFIG=1
		shift;;
		-t|--disable-timeout)
			DISABLE_TIMEOUT=1
		shift;;
		*)
		fatal_error "Unknown argument '$1'";;
	esac
done

# Config
if ! [ -f config.vars ] || [ $ONLY_CONFIG -gt 0 ]
then
	printf "\t${BOLD}Configuration${NC}\n\n"
	printf "The project directory (default: ../pipex): "
	read project_directory
	if [ -z "$project_directory" ]
	then
		project_directory="../pipex"
	fi

	if ! touch config.vars > /dev/null 2>&1
	then
		printf "${YELLOW}Unable to create the configuration file as your user...${NC}\n"
		PROJECT_DIRECTORY=$project_directory
		READ_CONFIG=0
	else
		echo "# This file was automatically generated by the pipex-tester" > config.vars
		echo "# https://github.com/vfurmane/pipex-tester" >> config.vars
		echo >> config.vars
		echo "PROJECT_DIRECTORY='$project_directory'" >> config.vars
	fi
fi

if [ $ONLY_CONFIG -gt 0 ]
then
	exit 0
fi

if [ $READ_CONFIG -gt 0 ]
then
	if ! [ -x "config.vars" ]
	then
		if ! chmod u+x run.sh > /dev/null 2>&1
		then
			fatal_error "The config.vars file is not executable...\nTry \`chmod +x config.vars\`"
		fi
	fi
	. config.vars
fi

if ! mkdir -p outs > /dev/null 2>&1
then
	fatal_error "Unable to create the out logs folder..."
fi
if ! [ -w outs ]
then
	fatal_error "Unable to write to the 'outs' folder as your user...${NC}"
fi

printf "\n"
printf "\t${BOLD}Tests${NC}\n\n"
num="00"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program compiles"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test make -C $PROJECT_DIRECTORY > outs/test-$num.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program is executable as ./pipex"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
if [ -x $PROJECT_DIRECTORY/pipex ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
pipex_test $PROJECT_DIRECTORY/pipex > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not crash with one parameter"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not crash with two parameters"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not crash with three parameters"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program exits with the last command's status code"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
PATH=$PWD:$PATH pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "./assets/exit.sh 5" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -eq 5 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles infile's open error"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "not-existing/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output when infile's open error occur is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "not-existing/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
< /dev/null grep Now | wc -w > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles outfile's open error"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" "not-existing/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles execve errors"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
chmod 644 assets/deepthought.txt
PATH=$PWD:$PATH pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "./assets/not-executable" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles path that doesn't exist"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
PATH=/not/existing:$PATH pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program uses the environment list"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
PATH=$PWD:$PATH VAR1="hello" VAR2="world" pipex_test $PROJECT_DIRECTORY/pipex "/dev/null" "./assets/env_var.sh" "cat" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
VAR1="hello" VAR2="world" ./assets/env_var.sh > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"cat\" \"ls\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "ls" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "ls" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
< assets/deepthought.txt cat | ls > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"grep Now\" \"head -2\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "head -2" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "head -2" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
< assets/deepthought.txt grep Now | head -2 > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"grep Now\" \"wc -w\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
< assets/deepthought.txt grep Now | wc -w > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"grep Now\" \"cat\" \"outs/test-xx.txt\"\n"
printf "${ULINE}then:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"wc -w\" \"cat\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "cat" "outs/test-$num.txt" > outs/test-$num.0-tty.txt 2>&1
status_code=$?
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "wc -w" "cat" "outs/test-$num.txt" > outs/test-$num.1-tty.txt 2>&1
if [ $status_code -eq 0 ] && [ $? -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "cat" "outs/test-$num.txt" > outs/test-$num.0-tty.txt 2>&1
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "wc -w" "cat" "outs/test-$num.txt" > outs/test-$num.1-tty.txt 2>&1
< assets/deepthought.txt grep Now | cat > outs/test-$num-original.txt
< assets/deepthought.txt wc -w | cat > outs/test-$num-original.txt
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"notexisting\" \"wc\" \"outs/test-xx.txt\"\n"
printf "${ULINE}(notexisting is a command that is not supposed to exist)${NC}\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "notexisting" "wc" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -eq 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command contains 'command not found'"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "notexisting" "wc" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
if grep "command not found" outs/test-$num-tty.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$YELLOW
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "notexisting" "wc" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
< /dev/null cat | wc > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"cat\" \"notexisting\" \"outs/test-xx.txt\"\n"
printf "${ULINE}(notexisting is a command that is not supposed to exist)${NC}\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program exits with the right status code"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "notexisting" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -eq 127 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command contains 'command not found'"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "notexisting" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
if grep "command not found" outs/test-$num-tty.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$YELLOW
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "notexisting" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
< assets/deepthought.txt cat | cat /dev/null > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"/dev/urandom\" \"cat\" \"head -1\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not timeout"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "/dev/urandom" "cat" "head -1" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1 &
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 254 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

pipex_summary
