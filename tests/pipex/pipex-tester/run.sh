#!/bin/bash

NC="\033[0m"
BOLD="\033[1m"
ULINE="\033[4m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
MAGENTA="\033[35m"

fatal_error()
{
	if [ -z "$1" ]
	then
		message="fatal error"
	else
		message="$1"
	fi
	if [ -z "$2" ]
	then
		exit_status=1
	else
		exit_status=$2
	fi
	printf "${RED}$message${NC}\n"
	exit $exit_status
}

commands_needed=("awk" "sleep" "date" "awk" "dirname" "touch" "chmod" "ping" "git" "mkdir" "make" "nm" "grep" "wc" "cat" "ls" "head")
for command_needed in "${commands_needed[@]}"
do
	command -v $command_needed || fatal_error "'$command_needed' command not installed... Aborting."
done

DISABLE_TIMEOUT=0

wait_for_timeout()
{
	sleep 2
	if kill -0 $1 > /dev/null 2>&1
	then
		kill $1
	fi
}

pipex_test()
{
	if [ $DISABLE_TIMEOUT -eq 0 ]
	then
		"$@" &
		bg_process=$!
		wait_for_timeout $bg_process &
		wait $bg_process
	else
		"$@"
	fi
	status_code=$?
	return $status_code
}

should_update()
{
	if [ -f .last-update ]
	then
		if source .last-update
		then
			last_hour=$(echo "$(date +%s) 3600" | awk '{printf "%d", $1 - $2}')
			if [ $LAST_UPDATE -le $last_hour ]
			then
				echo "LAST_UPDATE=$(date +%s)" > .last-update
				return 0
			else
				return 1
			fi
		else
			return 1
		fi
	else
		echo "LAST_UPDATE=$(date +%s)" > .last-update
		return 0
	fi
}

TESTS_OK=0
TESTS_KO=0
TESTS_TO=0
exec 3>&1

pipex_summary()
{
	exec 1>&3
	printf "\n\n"
	printf "\t${BOLD}Summary${NC}\n\n" > /dev/stdout
	
	[ $TESTS_OK -gt 0 ] && printf "${GREEN}$TESTS_OK OK${NC}"
	[ $TESTS_OK -gt 0 ] && [ $TESTS_KO -gt 0 ] && printf " - "
	[ $TESTS_KO -gt 0 ] && printf "${RED}$TESTS_KO KO${NC}"
	([ $TESTS_OK -gt 0 ] || [ $TESTS_KO -gt 0 ]) && [ $TESTS_TO -gt 0 ] && printf " - "
	[ $TESTS_TO -gt 0 ] && printf "${RED}$TESTS_TO TO${NC}"
	printf "\n\n"
	
	printf "${GREEN}OK${NC}: Test passed\n"
	printf "${YELLOW}OK${NC}: Not opitmal or like bash (should not invalidate the project)\n"
	printf "${RED}KO${NC}: Test did not pass\n"
	printf "${RED}TO${NC}: Test timed out\n"
	
	if [ $TESTS_KO -eq 0 ] && [ $TESTS_TO -eq 0 ]
	then
		exit 0
	else
		exit 1
	fi
}

cd "$(dirname "$0")"

printf "+------------------------------------------------------------------------------+\n"
printf "|                                                                              |\n"
printf "|                                                                              |\n"
printf "|                           ${ULINE}${MAGENTA}PIPEX TESTER${NC} by ${YELLOW}vfurmane${NC}                           |\n"
printf "|                                                                              |\n"
printf "|                                                                              |\n"
printf "+------------------------------------------------------------------------------+\n"
printf "\n\n"

CONFIG=0
READ_CONFIG=1

# Parse arguments
while [ $# -gt 0 ]
do
	case $1 in
		-c|--config)
			CONFIG=1
		shift;;
		-t|--disable-timeout)
			DISABLE_TIMEOUT=1
		shift;;
		*)
		fatal_error "Unknown argument '$1'";;
	esac
done

# Config
if ! [ -f config.vars ] || [ $CONFIG -gt 0 ]
then
	printf "\t${BOLD}Configuration${NC}\n\n"
	printf "The project directory (default: ../pipex): "
	read project_directory
	if [ -z "$project_directory" ]
	then
		project_directory="../pipex"
	fi
	if [ -z "$project_directory" ]
	then
		project_directory="../pipex"
	fi
	printf "\n"
	printf "Would you like to check for updates on run ?\nThis option is recommended as the tester is still actively updated\n"
	check_update=-1
	while [ $check_update -ne 0 ] && [ $check_update -ne 1 ]
	do
		printf "Check for update on run [Y/n] "
		read -N 1 -r check_update
		[[ "$check_update" != $'\n' ]] && echo
		case "$check_update" in
			[nN]) check_update=0 ;;
			[yY$'\n']) check_update=1 ;;
		esac
		if [ "$check_update" != "0" ] && [ "$check_update" != "1" ]
		then
			printf "${YELLOW}Unexpected answer. Please retry...${NC}\n"
			check_update=-1
		fi
	done

	if ! touch config.vars > /dev/null 2>&1
	then
		printf "${YELLOW}Unable to create the configuration file as your user...${NC}\n"
		PROJECT_DIRECTORY=$project_directory
		CHECK_UPDATE=$check_update
		READ_CONFIG=0
	else
		echo "# This file was automatically generated by the pipex-tester" > config.vars
		echo "# https://github.com/vfurmane/pipex-tester" >> config.vars
		echo >> config.vars
		echo "PROJECT_DIRECTORY='$project_directory'" >> config.vars
		echo "CHECK_UPDATE=$check_update" >> config.vars
	fi
fi

if [ $READ_CONFIG -gt 0 ]
then
	if ! [ -x "config.vars" ]
	then
		if ! chmod u+x run.sh > /dev/null 2>&1
		then
			fatal_error "The config.vars file is not executable...\nTry \`chmod +x config.vars\`"
		fi
	fi
	. config.vars
fi

if [ $CHECK_UPDATE -gt 0 ] && should_update
then
	if ping -c 1 example.org > /dev/null 2>&1
	then
		if [ $(git status --porcelain 2> /dev/null | wc -l) -eq 0 ]
		then
			git fetch origin master > /dev/null 2>&1
		fi
		if ! git diff-index --quiet origin/master -- \
		&& [ $(git status --porcelain 2> /dev/null | wc -l) -eq 0 ]
		then
			update=-1
			while [ $update -ne 0 ] && [ $update -ne 1 ]
			do
				printf "Would you like to update the tester [Y/n] "
				read -N 1 -r update
				[[ "$update" != $'\n' ]] && echo
				case "$update" in
					[nN]) update=0 ;;
					[yY$'\n']) update=1 ;;
				esac
				if [ "$update" != "0" ] && [ "$update" != "1" ]
				then
					printf "${YELLOW}Unexpected answer. Please retry...${NC}\n"
					update=-1
				fi
			done
			if [ $update -eq 1 ]
			then
				git pull origin master
			fi
		fi
	else
		printf "${YELLOW}Cannot check remote update...${NC}\n"
	fi
fi

if ! mkdir -p outs > /dev/null 2>&1
then
	fatal_error "Unable to create the out logs folder..."
fi
if ! [ -w outs ]
then
	fatal_error "Unable to write to the 'outs' folder as your user...${NC}"
fi

printf "\n"
printf "\t${BOLD}Tests${NC}\n\n"
trap pipex_summary SIGINT
num="00"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program compiles"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test make -C $PROJECT_DIRECTORY > outs/test-$num.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program is executable as ./pipex"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
if [ -x $PROJECT_DIRECTORY/pipex ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program doesn't use forbidden functions"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
nm -u $PROJECT_DIRECTORY/pipex | grep -Ev '(___error|___stack_chk_fail|___stack_chk_guard|access|close|dup|dup2|__errno_location|execve|exit|fork|free|__gmon_start__|__libc_start_main|malloc|open|perror|pipe|printf|read|strerror|unlink|wait|waitpid|write|dyld_stub_binder)(@|$)' > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 1 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	TESTS_KO=$(($TESTS_KO + 1))
	result="KO"
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not crash with no parameters"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not crash with one parameter"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not crash with two parameters"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not crash with three parameters"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program exits with the last command's status code"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
PATH=$PWD:$PATH pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "./assets/exit.sh 5" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -eq 5 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles infile's open error"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "not-existing/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output when infile's open error occur is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "not-existing/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
< /dev/null grep Now | wc -w > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles outfile's open error"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" "not-existing/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles execve errors"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
chmod 644 assets/deepthought.txt
PATH=$PWD:$PATH pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "./assets/not-executable" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -ne 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles path that doesn't exist"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
PATH=/not/existing:$PATH pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program uses the environment list"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
PATH=$PWD:$PATH VAR1="hello" VAR2="world" pipex_test $PROJECT_DIRECTORY/pipex "/dev/null" "./assets/env_var.sh" "cat" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
VAR1="hello" VAR2="world" ./assets/env_var.sh > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"cat\" \"ls\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "ls" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "ls" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
< assets/deepthought.txt cat | ls > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"grep Now\" \"head -2\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "head -2" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "head -2" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
< assets/deepthought.txt grep Now | head -2 > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"grep Now\" \"wc -w\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "wc -w" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
< assets/deepthought.txt grep Now | wc -w > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"grep Now\" \"cat\" \"outs/test-xx.txt\"\n"
printf "${ULINE}then:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"wc -w\" \"cat\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "cat" "outs/test-$num.txt" > outs/test-$num.0-tty.txt 2>&1
status_code=$?
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "wc -w" "cat" "outs/test-$num.txt" > outs/test-$num.1-tty.txt 2>&1
if [ $status_code -eq 0 ] && [ $? -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "grep Now" "cat" "outs/test-$num.txt" > outs/test-$num.0-tty.txt 2>&1
status_code=$?
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "wc -w" "cat" "outs/test-$num.txt" > outs/test-$num.1-tty.txt 2>&1
status_code2=$?
< assets/deepthought.txt grep Now | cat > outs/test-$num-original.txt
< assets/deepthought.txt wc -w | cat > outs/test-$num-original.txt
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1 && [ $status_code -ne 143 ] && [ $status_code2 -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ] || [ $status_code2 -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"notexisting\" \"wc\" \"outs/test-xx.txt\"\n"
printf "${ULINE}(notexisting is a command that is not supposed to exist)${NC}\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program handles the command"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "notexisting" "wc" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -eq 0 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command contains 'command not found'"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "notexisting" "wc" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if grep "command not found" outs/test-$num-tty.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
		result_color=$RED
	else
		TESTS_OK=$(($TESTS_OK + 1))
		result="OK"
		result_color=$YELLOW
	fi
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "notexisting" "wc" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
< /dev/null cat | wc > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"assets/deepthought.txt\" \"cat\" \"notexisting\" \"outs/test-xx.txt\"\n"
printf "${ULINE}(notexisting is a command that is not supposed to exist)${NC}\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program exits with the right status code"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "notexisting" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -le 128 ] # 128 is the last code that bash uses before signals
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	if [ $status_code -eq 127 ]
	then
		result_color=$GREEN
	else
		result_color=$YELLOW
	fi
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command contains 'command not found'"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "notexisting" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if grep "command not found" outs/test-$num-tty.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
		result_color=$RED
	else
		TESTS_OK=$(($TESTS_OK + 1))
		result="OK"
		result_color=$YELLOW
	fi
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The output of the command is correct"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "assets/deepthought.txt" "cat" "notexisting" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
< assets/deepthought.txt cat | cat /dev/null > outs/test-$num-original.txt 2>&1
if diff outs/test-$num-original.txt outs/test-$num.txt > /dev/null 2>&1 && [ $status_code -ne 143 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

# **************************************************************************** #

printf "\n${ULINE}The next tests will use the following command:${NC}\n"
printf "$PROJECT_DIRECTORY/pipex \"/dev/urandom\" \"cat\" \"head -1\" \"outs/test-xx.txt\"\n\n"

# TEST
num=$(echo "$num 1" | awk '{printf "%02d", $1 + $2}')
description="The program does not timeout"
printf "${BLUE}# $num: %-69s  []${NC}" "$description"
pipex_test $PROJECT_DIRECTORY/pipex "/dev/urandom" "cat" "head -1" "outs/test-$num.txt" > outs/test-$num-tty.txt 2>&1
status_code=$?
if [ $status_code -eq 0 ]
then
	TESTS_OK=$(($TESTS_OK + 1))
	result="OK"
	result_color=$GREEN
else
	if [ $status_code -eq 143 ]
	then
		TESTS_TO=$(($TESTS_TO + 1))
		result="TO"
	else
		TESTS_KO=$(($TESTS_KO + 1))
		result="KO"
	fi
	result_color=$RED
fi
printf "\r${result_color}# $num: %-69s [%s]\n${NC}" "$description" "$result"

pipex_summary
